<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="favicon.webp">
    <title>S/370 Demo Scene</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #scene-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
            color: #fff;
            font-size: 7rem;
            text-shadow: 0 0 10px #f0f, 0 0 20px #f0f, 0 0 30px #f0f;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        .rotating-text {
            transform-style: preserve-3d;
            animation: rotate3D 10s linear infinite;
        }

        @keyframes rotate3D {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(360deg); }
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
        }

        #start-button {
            padding: 20px 40px;
            font-size: 24px;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            text-transform: uppercase;
            transition: all 0.4s ease;
        }

        #start-button:hover {
            background: #fff;
            color: #000;
        }

        .audio-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: row;
            gap: 10px;
        }

        .control-button {
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            padding: 8px 16px;
            cursor: pointer;
            font-family: 'Courier New', Courier, monospace;
            text-transform: uppercase;
            font-size: 12px;
            transition: all 0.3s ease;
            width: 100px;
        }

        .control-button:hover {
            background: #fff;
            color: #000;
        }

        .control-button.active {
            background: #fff;
            color: #000;
        }

        /* Media query for mobile devices */
        @media (max-width: 768px) {
            .audio-controls {
                flex-direction: column;
            }
            
            .control-button {
                padding: 6px 12px;
                font-size: 10px;
                width: 80px;
            }
        }

        .version-number {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
        }

        .song-name {
            position: absolute;
            bottom: -20px;
            right: 0;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
        }

        .copyright {
            position: fixed;
            top: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
        }

        .scene-transition {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 9999;
        }

        .info-container {
            position: fixed;
            bottom: 30px;
            right: 10px;
            z-index: 1000;
            pointer-events: none;
            text-align: right;
        }

        .current-scene {
            color: rgba(255, 255, 255, 0.5);
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="audio-controls">
        <button id="mute-button" class="control-button">Mute</button>
        <button id="next-track" class="control-button">Next Track</button>
    </div>
    <div id="start-overlay">
        <button id="start-button">Click to Start</button>
    </div>
    <div id="scene-overlay">Scene 1: Neon City</div>
    <div class="version-number">v1.4</div>
    <div class="info-container">
        <div class="current-scene"></div>
        <div class="song-name"></div>
    </div>
    <div class="copyright">(c) by hot dog studios</div>
    <div class="scene-transition"></div>
    <script>

        // copyright 2024-2025 by hot dog studios
        // 0.01 humble beginnings
        // 0.02-0.5 add scenes and audio
        // 0.6 add version number and song name 
        // 0.7 favicon and copyright
        // 0.8 support mobile phones better
        // 0.9 ocean waves and reset camera when scenes wrap around
        // 1.0 fix helix and other small stuff 
        // 1.1 dimming between scenes, and mix songs randomly
        // 1.2 new neon tunnel 
        // 1.3 read from words file and show random words

        let wordPairs = [];

        // Scene Configuration
        const scenes = [
            {
                backgroundColor: 0x000000,
                meshType: "grid",
                meshColor: 0xff00ff,
                textColor: "#00ff00"
            },
            {
                backgroundColor: 0x000033,
                meshType: "hills",
                meshColor: 0x00ff00,
                textColor: "#ff00ff"
            },
            {
                backgroundColor: 0x330033,
                meshType: "sphereGrid",
                meshColor: 0x00ffff,
                textColor: "#ff6600"
            },
            {
                backgroundColor: 0x111111,
                meshType: "helix",
                meshColor: 0xff6600,
                textColor: "#ffff00"
            },
            {
                backgroundColor: 0x000000,
                meshType: "particleStorm",
                meshColor: 0x00ccff,
                textColor: "#ff33cc"
            },
            {
                backgroundColor: 0x000033,
                meshType: "oceanWaves",
                meshColor: 0xff00ff,
                textColor: "#ff3399"
            },
            {
                backgroundColor: 0x000000,
                meshType: "neonTunnel",
                meshColor: 0x39ff14,
                textColor: "#00ffff"
            },
            {
                backgroundColor: 0x000015,  // Very dark blue background
                meshType: "cosmicWeb",
                meshColor: 0x00ff88,       // Cyan-green color
                textColor: "#ff3366"       // Pink-red text
            }
        ];

        let currentSceneIndex = 0;

        // Three.js Setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 50);

        const wordContainer = document.getElementById("scene-overlay");

        // Lights
        const light = new THREE.PointLight(0xffffff, 1);
        light.position.set(0, 50, 50);
        scene.add(light);

        let mesh;

    function createMesh(type) {
        if (mesh) scene.remove(mesh);
        const currentScene = scenes[currentSceneIndex];
        const meshColor = currentScene.meshColor;

        console.log("Creating mesh of type:", type);
        console.log("Current scene:", currentScene);

        switch (type) {
            case "particleStorm":
                mesh = createParticleStorm();
                break;
            case "beatLines":
                mesh = createBeatLinesMesh();
                break;
            case "helix":
                mesh = createHelixMesh();
                break;
            case "grid":
                mesh = createGridMesh();
                break;
            case "hills":
                mesh = new THREE.Mesh(
                    createHillsMesh(),
                    new THREE.MeshStandardMaterial({ color: meshColor, wireframe: true })
                );
                break;
            case "sphereGrid":
                mesh = createSphereGridMesh();
                break;
            case "oceanWaves":
                mesh = createOceanWavesMesh();
                break;
            case "neonTunnel":
                mesh = createNeonTunnelMesh();
                break;
            case "cosmicWeb":
                mesh = createCosmicWeb();
                break;
            default:
                console.error("Unknown mesh type:", type);
                return;
        }

        scene.add(mesh);
    }

function createHelixMesh() {
    const group = new THREE.Group();
    const objectCount = 120; // Number of objects in the helix
    const radius = 35; // Radius of the helix
    const height = 70; // Height of the helix
    const turns = 4; // Number of turns in the helix

    const geometry = new THREE.SphereGeometry(3, 16, 16); // Geometry for helix elements
    const material = new THREE.MeshStandardMaterial({ color: scenes[currentSceneIndex].meshColor });

    for (let i = 0; i < objectCount; i++) {
        const angle = (i / objectCount) * (turns * Math.PI * 2); // Calculate angle for this object
        const y = (i / objectCount) * height - height / 2; // Spread objects vertically
        const x = radius * Math.cos(angle); // X-coordinate
        const z = radius * Math.sin(angle); // Z-coordinate

        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(x, y, z);
        group.add(sphere); // Add sphere to the group
    }

    return group; // Return the group containing all helix elements
}



        function createGridMesh() {
            const group = new THREE.Group();
            
            // Create main grid
            const gridSize = 100;
            const divisions = 50;
            const spacing = gridSize / divisions;
            
            // Create vertical and horizontal lines with varying heights
            for (let i = -gridSize/2; i <= gridSize/2; i += spacing) {
                // Create line geometries
                const verticalGeometry = new THREE.BufferGeometry();
                const horizontalGeometry = new THREE.BufferGeometry();
                
                const verticalPoints = [];
                const horizontalPoints = [];
                
                // Create points with more detail
                for (let j = -gridSize/2; j <= gridSize/2; j += spacing/2) {
                    // Add points for vertical line
                    verticalPoints.push(
                        i, 0, j,
                        i, 0, j + spacing/2
                    );
                    
                    // Add points for horizontal line
                    horizontalPoints.push(
                        j, 0, i,
                        j + spacing/2, 0, i
                    );
                }
                
                verticalGeometry.setAttribute('position', new THREE.Float32BufferAttribute(verticalPoints, 3));
                horizontalGeometry.setAttribute('position', new THREE.Float32BufferAttribute(horizontalPoints, 3));
                
                // Create materials with glow effect
                const material = new THREE.LineBasicMaterial({
                    color: scenes[currentSceneIndex].meshColor,
                    transparent: true,
                    opacity: 0.6
                });
                
                const verticalLine = new THREE.LineSegments(verticalGeometry, material);
                const horizontalLine = new THREE.LineSegments(horizontalGeometry, material);
                
                group.add(verticalLine);
                group.add(horizontalLine);
            }
            
            // Add animation data
            group.userData.animate = function(time) {
                const t = time * 0.001;
                
                group.children.forEach((line, index) => {
                    const positions = line.geometry.attributes.position.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        const x = positions[i];
                        const z = positions[i + 2];
                        
                        // Create complex wave pattern
                        const wave1 = Math.sin(x * 0.05 + t) * 5;
                        const wave2 = Math.cos(z * 0.05 + t * 0.7) * 5;
                        const wave3 = Math.sin(Math.sqrt(x * x + z * z) * 0.03 + t * 1.2) * 3;
                        const wave4 = Math.cos((x + z) * 0.05 + t * 0.5) * 4;
                        
                        // Combine waves with distance-based amplitude
                        const distance = Math.sqrt(x * x + z * z);
                        const falloff = Math.max(0, 1 - distance / (gridSize * 0.7));
                        positions[i + 1] = (wave1 + wave2 + wave3 + wave4) * falloff;
                    }
                    
                    line.geometry.attributes.position.needsUpdate = true;
                    
                    // Pulse opacity based on wave height
                    const avgHeight = Math.sin(t + index * 0.1) * 0.5 + 0.5;
                    line.material.opacity = 0.3 + avgHeight * 0.7;
                    
                    // Color cycling
                    const hue = (t * 0.1 + index * 0.01) % 1;
                    line.material.color.setHSL(hue, 0.8, 0.5);
                });
                
                // Rotate entire grid slowly
                group.rotation.y = Math.sin(t * 0.1) * 0.2;
            };
            
            return group;
        }

        function createHillsMesh() {
            const geometry = new THREE.PlaneGeometry(1000, 1000, 200, 200);
            geometry.rotateX(-Math.PI / 2);

            const positionAttribute = geometry.attributes.position;
            const vertex = new THREE.Vector3();

            for (let i = 0; i < positionAttribute.count; i++) {
                vertex.fromBufferAttribute(positionAttribute, i);
                vertex.y = Math.sin(vertex.x * 0.02) * Math.cos(vertex.z * 0.02) * 15;
                positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }

            positionAttribute.needsUpdate = true;
            return geometry;
        }

        function createWaveMesh() {
            const geometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            geometry.rotateX(-Math.PI / 2);
            
            const positionAttribute = geometry.attributes.position;
            const vertex = new THREE.Vector3();
            
            // Create multiple overlapping wave patterns
            for (let i = 0; i < positionAttribute.count; i++) {
                vertex.fromBufferAttribute(positionAttribute, i);
                
                // Create complex wave pattern using multiple frequencies
                const wave1 = Math.sin(vertex.x * 0.03) * 15;
                const wave2 = Math.cos(vertex.z * 0.04) * 10;
                const wave3 = Math.sin(vertex.x * 0.02 + vertex.z * 0.02) * 20;
                const wave4 = Math.cos(Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z) * 0.03) * 15;
                
                // Combine waves with distance-based amplitude
                const distance = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);
                const falloff = Math.max(0, 1 - distance / 500); // Reduce height at edges
                vertex.y = (wave1 + wave2 + wave3 + wave4) * falloff;
                
                positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            
            // Add animation data
            geometry.userData.originalPositions = positionAttribute.array.slice();
            geometry.userData.animate = function(time) {
                const positions = positionAttribute.array;
                const original = geometry.userData.originalPositions;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const x = original[i];
                    const z = original[i + 2];
                    
                    // Animate waves over time
                    const wave1 = Math.sin(x * 0.03 + time * 0.001) * 15;
                    const wave2 = Math.cos(z * 0.04 + time * 0.002) * 10;
                    const wave3 = Math.sin(x * 0.02 + z * 0.02 + time * 0.001) * 20;
                    const wave4 = Math.cos(Math.sqrt(x * x + z * z) * 0.03 - time * 0.001) * 15;
                    
                    const distance = Math.sqrt(x * x + z * z);
                    const falloff = Math.max(0, 1 - distance / 500);
                    
                    positions[i + 1] = (wave1 + wave2 + wave3 + wave4) * falloff;
                }
                
                positionAttribute.needsUpdate = true;
            };
            
            return geometry;
        }

		function createSphereGridMesh() {
		    const group = new THREE.Group();
		    const radius = 2;
		    const spacing = 12;
		    const gridSize = 20; // Reduced for better performance and denser look
		    
		    // Create color palette for transitions
		    const colors = [
		        new THREE.Color(scenes[currentSceneIndex].meshColor),
		        new THREE.Color(0xffffff),
		        new THREE.Color(0x00ffff)
		    ];

		    // Create spheres with more interesting materials
		    for (let x = -gridSize / 2; x < gridSize / 2; x++) {
		        for (let z = -gridSize / 2; z < gridSize / 2; z++) {
		            // Create main sphere
		            const sphereGeometry = new THREE.SphereGeometry(radius, 16, 16);
		            const sphereMaterial = new THREE.MeshPhongMaterial({ 
		                color: scenes[currentSceneIndex].meshColor,
		                emissive: scenes[currentSceneIndex].meshColor,
		                emissiveIntensity: 0.5,
		                shininess: 50,
		                transparent: true,
		                opacity: 0.8
		            });
		            
		            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		            
		            // Create glow effect
		            const glowGeometry = new THREE.SphereGeometry(radius * 1.2, 16, 16);
		            const glowMaterial = new THREE.MeshBasicMaterial({
		                color: scenes[currentSceneIndex].meshColor,
		                transparent: true,
		                opacity: 0.3,
		                blending: THREE.AdditiveBlending,
		                side: THREE.BackSide
		            });
		            
		            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
		            sphere.add(glow);
		            
		            // Position with wave offset
		            sphere.position.set(
		                x * spacing,
		                0,
		                z * spacing
		            );
		            
		            // Store initial position and random phase
		            sphere.userData = {
		                initialY: sphere.position.y,
		                phase: Math.random() * Math.PI * 2,
		                pulseSpeed: 0.5 + Math.random() * 0.5,
		                colorPhase: Math.random() * Math.PI * 2
		            };
		            
		            group.add(sphere);
		        }
		    }

		    // Add animation data
		    group.userData.animate = function(time) {
		        const t = time * 0.001;
		        
		        group.children.forEach((sphere, index) => {
		            // Calculate wave position
		            const x = sphere.position.x;
		            const z = sphere.position.z;
		            const distance = Math.sqrt(x * x + z * z);
		            
		            // Complex wave motion
		            const wave1 = Math.sin(distance * 0.05 + t) * 5;
		            const wave2 = Math.cos(t * 0.5 + sphere.userData.phase) * 3;
		            const wave3 = Math.sin(t * 0.3 + distance * 0.05) * 4;
		            
		            // Combine waves
		            sphere.position.y = wave1 + wave2 + wave3;
		            
		            // Pulse size
		            const scale = 1 + Math.sin(t * sphere.userData.pulseSpeed + sphere.userData.phase) * 0.2;
		            sphere.scale.set(scale, scale, scale);
		            
		            // Color transition
		            const colorT = (Math.sin(t * 0.5 + sphere.userData.colorPhase) + 1) / 2;
		            const currentColor = new THREE.Color();
		            const colorIndex = Math.floor(t * 0.2) % colors.length;
		            const nextColorIndex = (colorIndex + 1) % colors.length;
		            
		            currentColor.copy(colors[colorIndex]).lerp(colors[nextColorIndex], colorT);
		            
		            // Apply color to both sphere and glow
		            sphere.material.color = currentColor;
		            sphere.material.emissive = currentColor;
		            sphere.children[0].material.color = currentColor;
		            
		            // Adjust opacity based on height
		            const heightFactor = (sphere.position.y + 10) / 20;
		            sphere.material.opacity = 0.5 + heightFactor * 0.5;
		            sphere.children[0].material.opacity = 0.2 + heightFactor * 0.3;
		            
		            // Rotate individual spheres
		            sphere.rotation.x = t * 0.2 + sphere.userData.phase;
		            sphere.rotation.y = t * 0.3 + sphere.userData.phase;
		        });
		        
		        // Rotate entire grid slowly
		        group.rotation.y = Math.sin(t * 0.1) * 0.2;
		    };
		    
		    return group;
		}

        function createBeatLinesMesh() {
            const group = new THREE.Group();
            const lineCount = 100;
            const spacing = 10;
            const lineGeometry = new THREE.BoxGeometry(1, 1, 1000);
            const lineMaterial = new THREE.MeshStandardMaterial({ 
                color: scenes[currentSceneIndex].meshColor,
                emissive: scenes[currentSceneIndex].meshColor,
                emissiveIntensity: 0.5
            });

            for (let x = -lineCount / 2; x < lineCount / 2; x++) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(x * spacing, 0, 0);
                line.scale.set(1, 1, 1);  // Adjust line thickness if needed
                group.add(line);
            }

            return group;
        }

        // New ocean waves implementation
        function createOceanWavesMesh() {
            const simplex = new SimplexNoise();
            const group = new THREE.Group();
            
            // Create multiple layers of waves
            for (let layer = 0; layer < 5; layer++) {
                const waveGeometry = new THREE.BufferGeometry();
                const wavePoints = [];
                const gridSize = 100;
                const segmentSize = 20;
                
                // Create grid of points
                for (let z = -gridSize; z < gridSize; z++) {
                    for (let x = -gridSize; x < gridSize; x++) {
                        wavePoints.push(x * segmentSize, 0, z * segmentSize);
                    }
                }
                
                waveGeometry.setAttribute('position', new THREE.Float32BufferAttribute(wavePoints, 3));
                
                // Create lines connecting points
                const indices = [];
                const size = gridSize * 2;
                
                for (let z = 0; z < size - 1; z++) {
                    for (let x = 0; x < size - 1; x++) {
                        const a = x + z * size;
                        const b = (x + 1) + z * size;
                        const c = x + (z + 1) * size;
                        const d = (x + 1) + (z + 1) * size;
                        
                        indices.push(a, b, a, c);
                        if (x === size - 2) indices.push(b, d);
                        if (z === size - 2) indices.push(c, d);
                    }
                }
                
                waveGeometry.setIndex(indices);
                
                const waveMaterial = new THREE.LineBasicMaterial({
                    color: scenes[currentSceneIndex].meshColor,
                    opacity: 0.5 - layer * 0.1,
                    transparent: true
                });
                
                const waveMesh = new THREE.LineSegments(waveGeometry, waveMaterial);
                waveMesh.position.y = layer * 10;
                group.add(waveMesh);
            }
            
            return group;
        }

        function createNeonTunnelMesh() {
            const group = new THREE.Group();
            const ringCount = 40;
            
            // Create a color palette for dynamic color changes
            const colors = [
                new THREE.Color(0x39ff14),  // Neon green
                new THREE.Color(0xff1493),  // Deep pink
                new THREE.Color(0x00ffff),  // Cyan
                new THREE.Color(0xff4500)   // Orange-red
            ];
            
            for (let i = 0; i < ringCount; i++) {
                // Create main ring with varying sizes
                const radius = 30 + Math.sin(i * 0.2) * 5;
                const thickness = 2 + Math.sin(i * 0.5) * 1;
                const geometry = new THREE.RingGeometry(radius, radius + thickness, 32);
                
                // Create material with dynamic color
                const material = new THREE.MeshBasicMaterial({
                    color: colors[i % colors.length],
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                
                // Create outer glow ring
                const glowGeometry = new THREE.RingGeometry(radius - 2, radius + thickness + 2, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: colors[i % colors.length],
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                
                // Create energy particles around the ring
                const particleCount = 50;
                const particleGeometry = new THREE.BufferGeometry();
                const particlePositions = new Float32Array(particleCount * 3);
                
                for (let j = 0; j < particleCount; j++) {
                    const angle = (j / particleCount) * Math.PI * 2;
                    const r = radius + (Math.random() - 0.5) * 5;
                    particlePositions[j * 3] = Math.cos(angle) * r;
                    particlePositions[j * 3 + 1] = Math.sin(angle) * r;
                    particlePositions[j * 3 + 2] = 0;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                
                const particleMaterial = new THREE.PointsMaterial({
                    color: colors[i % colors.length],
                    size: 0.5,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const ring = new THREE.Mesh(geometry, material);
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                
                const ringGroup = new THREE.Group();
                ringGroup.add(ring);
                ringGroup.add(glow);
                ringGroup.add(particles);
                
                // Add some rotation offset
                ringGroup.rotation.x = Math.sin(i * 0.1) * 0.1;
                ringGroup.rotation.y = Math.cos(i * 0.1) * 0.1;
                
                // Position with slight offset for more organic feel
                ringGroup.position.x = Math.sin(i * 0.2) * 10;
                ringGroup.position.y = Math.cos(i * 0.3) * 10;
                ringGroup.position.z = -200 - (i * 100);
                
                // Store initial position for animation
                ringGroup.userData = {
                    initialX: ringGroup.position.x,
                    initialY: ringGroup.position.y,
                    speed: 2.0 + Math.random() * 0.5,
                    rotationSpeed: 0.01 + Math.random() * 0.02,
                    particleRotation: Math.random() * Math.PI * 2
                };
                
                group.add(ringGroup);
            }
            
            // Add animation data
            group.userData.animate = function(time) {
                const t = time * 0.001;
                
                group.children.forEach((ringGroup, i) => {
                    // Move rings forward
                    ringGroup.position.z += ringGroup.userData.speed;
                    
                    // Add wave motion
                    ringGroup.position.x = ringGroup.userData.initialX + Math.sin(t + i * 0.2) * 15;
                    ringGroup.position.y = ringGroup.userData.initialY + Math.cos(t * 0.7 + i * 0.3) * 15;
                    
                    // Rotate rings
                    ringGroup.rotation.z += ringGroup.userData.rotationSpeed;
                    
                    // Rotate particles around ring
                    const particles = ringGroup.children[2];
                    particles.rotation.z = ringGroup.userData.particleRotation + t;
                    
                    // Pulse the glow
                    const glow = ringGroup.children[1];
                    glow.material.opacity = 0.3 + Math.sin(t * 2 + i * 0.5) * 0.2;
                    
                    // Color cycling
                    const colorIndex = Math.floor((t + i * 0.1) % colors.length);
                    const nextColorIndex = (colorIndex + 1) % colors.length;
                    const mixFactor = ((t + i * 0.1) % 1);
                    
                    const currentColor = colors[colorIndex].clone();
                    currentColor.lerp(colors[nextColorIndex], mixFactor);
                    
                    ringGroup.children.forEach(child => {
                        child.material.color = currentColor;
                    });
                    
                    // Reset position when too close
                    if (ringGroup.position.z > 100) {
                        ringGroup.position.z = -4000;
                        ringGroup.position.x = ringGroup.userData.initialX;
                        ringGroup.position.y = ringGroup.userData.initialY;
                    }
                });
            };
            
            return group;
        }

        // Add this new function for the Cosmic Web scene
        function createCosmicWeb() {
            const group = new THREE.Group();
            
            // Create nodes (connection points)
            const nodeCount = 100;  // Doubled number of nodes
            const nodes = [];
            const nodeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const nodeMaterial = new THREE.MeshPhongMaterial({
                color: scenes[currentSceneIndex].meshColor,
                emissive: scenes[currentSceneIndex].meshColor,
                emissiveIntensity: 0.5
            });

            // Distribute nodes in 3D space
            for (let i = 0; i < nodeCount; i++) {
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                const radius = 30 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                node.position.x = radius * Math.sin(phi) * Math.cos(theta);
                node.position.y = radius * Math.sin(phi) * Math.sin(theta);
                node.position.z = radius * Math.cos(phi);
                
                nodes.push(node);
                group.add(node);
            }

            // Create energy beams between nearby nodes
            const beamMaterial = new THREE.LineBasicMaterial({
                color: scenes[currentSceneIndex].meshColor,
                transparent: true,
                opacity: 0.3
            });

            nodes.forEach((node, i) => {
                nodes.slice(i + 1).forEach(otherNode => {
                    const distance = node.position.distanceTo(otherNode.position);
                    if (distance < 40) { // Increased connection distance
                        const points = [];
                        points.push(node.position);
                        points.push(otherNode.position);
                        
                        const beamGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const beam = new THREE.Line(beamGeometry, beamMaterial);
                        group.add(beam);
                    }
                });
            });

            // Add floating energy particles
            const particleCount = 4000;  // Doubled particle count
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const particleSpeeds = new Float32Array(particleCount);
            const particlePaths = new Float32Array(particleCount * 6); // Start and end points

            // Initialize particles along the beams
            for (let i = 0; i < particleCount; i++) {
                // Random position between two random nodes
                const node1 = nodes[Math.floor(Math.random() * nodes.length)];
                const node2 = nodes[Math.floor(Math.random() * nodes.length)];
                
                particlePaths[i * 6] = node1.position.x;
                particlePaths[i * 6 + 1] = node1.position.y;
                particlePaths[i * 6 + 2] = node1.position.z;
                particlePaths[i * 6 + 3] = node2.position.x;
                particlePaths[i * 6 + 4] = node2.position.y;
                particlePaths[i * 6 + 5] = node2.position.z;
                
                particleSpeeds[i] = 0.2 + Math.random() * 0.8; // Random speed for each particle
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: scenes[currentSceneIndex].meshColor,
                size: 0.2,  // Slightly smaller particles for better performance
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            group.add(particleSystem);

            // Add animation
            group.userData.animate = function(time) {
                // Pulse nodes
                nodes.forEach((node, i) => {
                    const scale = 1 + Math.sin(time * 0.001 + i * 0.5) * 0.3;
                    node.scale.set(scale, scale, scale);
                });

                // Animate particles along paths
                const positions = particleGeometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    const progress = (time * 0.001 * particleSpeeds[i]) % 1;
                    
                    // Lerp between start and end points
                    positions[i * 3] = particlePaths[i * 6] + (particlePaths[i * 6 + 3] - particlePaths[i * 6]) * progress;
                    positions[i * 3 + 1] = particlePaths[i * 6 + 1] + (particlePaths[i * 6 + 4] - particlePaths[i * 6 + 1]) * progress;
                    positions[i * 3 + 2] = particlePaths[i * 6 + 2] + (particlePaths[i * 6 + 5] - particlePaths[i * 6 + 2]) * progress;
                }
                
                particleGeometry.attributes.position.needsUpdate = true;

                // Rotate entire structure slowly
                group.rotation.y += 0.001;
                group.rotation.x = Math.sin(time * 0.0002) * 0.3;
            };

            return group;
        }

        async function loadWordPairs() {
            try {
                const response = await fetch('words');
                const text = await response.text();
                wordPairs = text.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0)
                    .map(line => line.split(/\s+/).slice(0, 2));
            } catch (error) {
                console.error('Error loading words file:', error);
                // Fallback word pairs if file can't be loaded
                wordPairs = [
                    ['MVS/XA', '31 bit'],
                    ['VM/SP', 'moshix'],
                    ['VTAM', 'VSAM'],
                    ['COBOL', 'PL/I'],
                    ['TSO', 'ISPF'],
                    ['IPL', 'IML'],
                    ['REXX', 'SNA'],
                    ['D A,L', 'Q N']
                ];
            }
        }

        function updateScene(direction = 1) {
            const transition = document.querySelector('.scene-transition');
            transition.style.opacity = '0.7';
            
            setTimeout(() => {
                currentSceneIndex = (currentSceneIndex + direction + scenes.length) % scenes.length;
                const currentScene = scenes[currentSceneIndex];
                
                // Get random word pair
                const randomPair = wordPairs[Math.floor(Math.random() * wordPairs.length)];
                
                wordContainer.innerHTML = '';
                const textElement = document.createElement('div');
                textElement.className = 'rotating-text';
                textElement.textContent = randomPair.join(' ');
                textElement.style.color = currentScene.textColor;
                textElement.style.textShadow = `0 0 10px ${currentScene.textColor}, 
                                               0 0 20px ${currentScene.textColor}, 
                                               0 0 30px ${currentScene.textColor}`;
                
                wordContainer.appendChild(textElement);
                
                // Reset camera position based on scene type
                if (currentScene.meshType === "oceanWaves") {
                    camera.position.set(0, 200, 300);
                } else {
                    camera.position.set(0, 40, 100);
                }
                camera.lookAt(0, 0, 0);
                
                renderer.setClearColor(currentScene.backgroundColor);
                createMesh(currentScene.meshType);
                
                // Remove transition effect
                setTimeout(() => {
                    transition.style.opacity = '0';
                }, 150);  // Brief delay before removing dim effect
                
                updateSongDisplay();
                
            }, 300);
        }

        // Add keyboard event listener
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'ArrowRight':
                case 'ArrowDown':
                case ' ': // Space bar
                    // Clear existing interval and start a new one
                    clearInterval(autoAdvanceInterval);
                    updateScene(1);  // Move forward
                    autoAdvanceInterval = setInterval(() => {
                        updateScene(1);
                    }, 10000);
                    break;
                case 'ArrowLeft':
                case 'ArrowUp':
                    // Clear existing interval and start a new one
                    clearInterval(autoAdvanceInterval);
                    updateScene(-1); // Move backward
                    autoAdvanceInterval = setInterval(() => {
                        updateScene(1);
                    }, 10000);
                    break;
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now();
            
            if (mesh) {
                if (scenes[currentSceneIndex].meshType === "wave") {
                    // Animate the wave mesh
                    mesh.geometry.userData.animate(time);
                } else if (scenes[currentSceneIndex].meshType === "oceanWaves") {
                    const time = Date.now() * 0.001;
                    
                    mesh.children.forEach((waveMesh, layerIndex) => {
                        const positions = waveMesh.geometry.attributes.position.array;
                        const simplex = new SimplexNoise(layerIndex);
                        
                        for (let i = 0; i < positions.length; i += 3) {
                            const x = positions[i];
                            const z = positions[i + 2];
                            
                            // Create organic wave movement using noise
                            positions[i + 1] = 
                                simplex.noise3D(
                                    x * 0.003 + time * 0.2, 
                                    z * 0.003, 
                                    time * 0.5
                                ) * 30 * (1 + layerIndex * 0.5);
                        }
                        
                        waveMesh.geometry.attributes.position.needsUpdate = true;
                    });
                    
                    // Rotate camera around the waves
                    const radius = 300;
                    const cameraSpeed = 0.1;
                    camera.position.x = Math.sin(time * cameraSpeed) * radius;
                    camera.position.z = Math.cos(time * cameraSpeed) * radius;
                    camera.position.y = 200 + Math.sin(time * 0.5) * 20;
                    camera.lookAt(0, 0, 0);
                    
                    // Move the entire wave system
                    mesh.position.z += 0.5;
                    if (mesh.position.z > 1000) {
                        mesh.position.z = -1000;
                    }
                } else if (scenes[currentSceneIndex].meshType === "grid") {
                    mesh.userData.animate(time);
                } else if (scenes[currentSceneIndex].meshType !== "helix") {
                    mesh.position.z += 0.2;
                    if (mesh.position.z > 500) {
                        mesh.position.z = -500;
                    }
                } else {
                    mesh.rotation.y += 0.01;
                }

                if (scenes[currentSceneIndex].meshType === "neonTunnel") {
                    mesh.userData.animate(time);
                }

                if (scenes[currentSceneIndex].meshType === "sphereGrid") {
                    mesh.userData.animate(time);
                }
            }
            renderer.render(scene, camera);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await loadWordPairs();
            updateScene(0); // Initial scene setup
            animate();
            
            // Start auto-advance
            autoAdvanceInterval = setInterval(() => {
                updateScene(1);
            }, 10000); // Change scene every 10 seconds
        });

        // Initialize variables for audio
        let audio, audioContext, analyser, source;
        const songList = shuffleArray([
            'Parallax.mp3',
            'Aloft_BGM.flac',
	    'nocturnal.flac',
	    'Siberian.flac',
            'Degradation.mp3',
            'Biosignature_BGM.flac',
            'Cipher_BGM.flac',
            'Cosmic_Solitude_BGM.flac',
            'Melancholy_BGM.flac',
            'Moon.mp3',
            'Fear.mp3'
        ]);
        let currentSongIndex = 0;

        // Initialize audio setup function
        function initAudio() {
            audio = new Audio(songList[currentSongIndex]);
            audio.loop = false;  // Disable loop since we want to play next song
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            source = audioContext.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            
            // Add ended event listener to play next song
            audio.addEventListener('ended', playNextSong);
            
            // Update song display
            updateSongDisplay();
            
            audio.play();
            document.getElementById('start-overlay').style.display = 'none';
        }

        // Function to play next song
        function playNextSong() {
            currentSongIndex = (currentSongIndex + 1) % songList.length;
            
            // Create new audio element
            const newAudio = new Audio(songList[currentSongIndex]);
            newAudio.loop = false;
            
            // Stop and disconnect old audio
            if (audio) {
                audio.pause();
                source.disconnect();
            }
            
            // Set up new audio
            audio = newAudio;
            source = audioContext.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
            
            // Add ended event listener
            audio.addEventListener('ended', playNextSong);
            
            // Maintain mute state
            audio.muted = muteButton.classList.contains('active');
            
            // Update song display
            updateSongDisplay();
            
            // Start playing
            audio.play();
        }

        // Add click event listener
        document.getElementById('start-button').addEventListener('click', () => {
            initAudio();
        });

        const frequencyData = new Uint8Array(analyser?.frequencyBinCount || 0);

        function updateAudio() {
            if (analyser) {  // Only run if analyser exists
                analyser.getByteFrequencyData(frequencyData);
            }
            // Use frequencyData to adjust mesh properties if needed
            requestAnimationFrame(updateAudio);
        }

        updateAudio();

        // Add mute button functionality
        const muteButton = document.getElementById('mute-button');
        muteButton.addEventListener('click', () => {
            if (audio) {
                audio.muted = !audio.muted;
                muteButton.textContent = audio.muted ? 'Unmute' : 'Mute';
                muteButton.classList.toggle('active', audio.muted);
            }
        });

        // Add next track button functionality
        const nextButton = document.getElementById('next-track');
        nextButton.addEventListener('click', () => {
            if (audio) {
                playNextSong();
            }
        });

        function updateSongDisplay() {
            const songName = songList[currentSongIndex]
                .replace('.mp3', '')
                .replace('.flac', '');
            document.querySelector('.song-name').textContent = songName;
            document.querySelector('.current-scene').textContent = scenes[currentSceneIndex].meshType;
        }

        // Add this function to shuffle arrays
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        if (scenes[currentSceneIndex].meshType === "neonTunnel") {
            const time = Date.now() * 0.001;
            
            mesh.children.forEach(ringGroup => {
                // Increase movement speed here
                ringGroup.position.z += 0.66;  // Doubled from 0.33
                
                // Calculate curve based on z position
                const zPos = ringGroup.position.z;
                
                // Only start curving after a certain distance
                if (zPos < -3000) {
                    const curveAmount = 100;
                    const frequency = 0.011;
                    ringGroup.position.x = Math.sin((zPos + 1000) * frequency) * curveAmount;
                    
                    const tangent = Math.cos((zPos + 1000) * frequency) * frequency * curveAmount;
                    ringGroup.rotation.y = Math.atan(tangent);
                } else {
                    ringGroup.position.x = 0;
                    ringGroup.rotation.y = 0;
                }
                
                // Reset ring position
                if (ringGroup.position.z > 0) {
                    ringGroup.position.z = -8000;
                    ringGroup.position.x = 0;
                    ringGroup.rotation.y = 0;
                }
                
                // Rotate halo
                ringGroup.children[1].rotation.z += 0.01;
            });
            
            // Camera movement
            const lookAheadZ = -1000;
            const lookAheadX = Math.sin((lookAheadZ + 1000) * 0.001) * 30;
            camera.position.set(
                Math.sin(time * 0.1) * 10,
                Math.cos(time * 0.25) * 5,
                50
            );
            camera.lookAt(lookAheadX, 0, lookAheadZ);
        }

        // Replace the createBeatLinesMesh function with this:
        function createParticleStorm() {
            const group = new THREE.Group();
            
            // Create particle system
            const particleCount = 5000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                // Random positions in a sphere
                const radius = Math.random() * 50;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i + 2] = radius * Math.cos(phi);
                
                // Colors
                colors[i] = 0.5 + Math.random() * 0.5;     // R
                colors[i + 1] = 0.2 + Math.random() * 0.3; // G
                colors[i + 2] = 1.0;                       // B
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create particle material
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            // Create particle system
            const particleSystem = new THREE.Points(particles, particleMaterial);
            group.add(particleSystem);
            
            // Create central core (icosahedron)
            const coreGeometry = new THREE.IcosahedronGeometry(10, 1);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: scenes[currentSceneIndex].meshColor,
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            group.add(core);
            
            // Add animation data to the group
            group.userData.animate = function(time) {
                // Rotate the entire group
                group.rotation.y += 0.002;
                
                // Animate particles
                const positions = particles.attributes.position.array;
                const colors = particles.attributes.color.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // Spiral motion
                    const x = positions[i];
                    const y = positions[i + 1];
                    const z = positions[i + 2];
                    
                    const r = Math.sqrt(x * x + z * z);
                    const theta = Math.atan2(z, x) + 0.01;
                    
                    positions[i] = r * Math.cos(theta);
                    positions[i + 2] = r * Math.sin(theta);
                    positions[i + 1] = y + Math.sin(time * 0.001 + r * 0.1) * 0.2;
                    
                    // Pulse colors
                    const colorPulse = Math.sin(time * 0.001 + r * 0.1) * 0.2 + 0.8;
                    colors[i] = colorPulse;
                    colors[i + 1] = colorPulse * 0.5;
                }
                
                particles.attributes.position.needsUpdate = true;
                particles.attributes.color.needsUpdate = true;
                
                // Animate core
                core.rotation.x += 0.01;
                core.rotation.y += 0.005;
                const scale = 1 + Math.sin(time * 0.001) * 0.1;
                core.scale.set(scale, scale, scale);
            };
            
            return group;
        }
    </script>
</body>
</html>

